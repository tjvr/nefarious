
define Any:a = Any:b {
    return (EQUAL a b)
}


macro Digits:text {
    return (PARSE_INT text)
}
same precedence {
    define Int:a + Int:b {
        return (INT_ADD a b)
    }
    define Int:a - Int:b {
        return (INT_SUB a b)
    }
}
same precedence {
    define Int:a * Int:b {
        return (INT_MUL a b)
    }
    define Int:a mod Int:b {
        return (INT_MOD a b)
    }
    define Int:a / Int:b {
        // TODO fractions
    }
}
define Int:a < Int:b {
    return (INT_LT a b)
}
define Int:a = Int:b {
    return (INT_EQ a b)
}
define int Text:text {
    return (PARSE_INT text)
}
define round Decimal:dec {
    return (DEC_ROUND dec)
}
define random Int:from to Int:to {
    return (INT_ADD from (DEC_ROUND (DEC_MUL (RANDOM) (INT_SUB to from))))
}
define text Int:num {
    return (INT_TEXT num)
}



define not Bool:bool {
    return (NOT bool)
}
define Bool:a and (Uneval Bool):b {
    JUMP_IF a end
    return false
label end
    return (CALL b)
}
define Bool:a or (Uneval Bool):b {
    JUMP_IF a end
    return (CALL b)
label end
    return true
}


define empty list {
    return (NEW_LIST)
}
define length of List:list {
    return (LIST_LENGTH list)
}
define is List:list empty? {
    return (INT_EQ 0 (LIST_LENGTH list))
}
define (List T):list [ Int:index ] {
    return T:(LIST_GET list index)
}
define item Int:index of (List T):list {
    return T:(LIST_GET list index)
}
define (List T):list [ Int:index ] := T:value {
    LIST_SET list index value
}


define join Text:a Text:b {
    return (TEXT_CONCAT a b)
}
define length of Text:text {
    return (TEXT_LENGTH text)
}


define if Bool:cond then (Uneval T):tv else (Uneval T):fv {
    var v := (CALL cond)
    JUMP_UNLESS v iffalse
    return (CALL tv)
label iffalse
    return (CALL fv)
}

define repeat until (Uneval Bool):cond Block:body {
    var v
label entry
    v := (CALL cond)
    JUMP_IF v end
    CALL body
    JUMP entry
label end
}

define repeat Int:times Block:body {
    var count := times
label entry
    JUMP_IF (INT_EQ 0 count) end
    CALL body
    count := (INT_SUB count 1)
    JUMP entry
label end
}




// TODO decimal
define wait Int:dur secs {
    WAIT dur
}

/*****************************************************************************/

define abs of Dec:num  { return dec (MATH "abs" (float num)) }
define sqrt of Dec:num { return dec (MATH "sqrt" (float num)) }
define sin of Dec:num  { return dec (MATH "sin" (float num)) }
define cos of Dec:num  { return dec (MATH "abs" (float num)) }

define float Dec:dec {
    // TODO dec -> Float
}
define dec Float:float {
    // TODO float -> Dec
}

/*****************************************************************************/

define if Bool:cond then (Uneval T):tv else (Uneval T):fv {
    var v
    JUMP_UNLESS cond iffalse
    CALL v tv
    RETURN T:v
label iffalse
    CALL v fv
    RETURN T:v
}


define while (Uneval Bool):cond Block:body {
    var v
label entry
    CALL v cond
    JUMP_UNLESS v end
    CALL _ body
    JUMP entry
label end
}

define for (Upvar T):index in (List T):list Block:Body {
    index := 1
    var stop?
label loop
    INT_GT stop? index (length of list)
    JUMP_IF stop? end
    var := index
    CALL _ body
    index := index + 1
    JUMP loop
label end
}

define map (Block T):func over List:list {
    var stop?
    var index := 1
    var output := empty list
    var item
label loop
    INT_GT stop? index (length of list)
    JUMP_IF stop? end
    LIST_GET item list index
    ARG item
    CALL item func
    LIST_ADD output item
label end
    RETURN (List T):output
}




/*****************************************************************************/

define range Int:from to Int:to {
}



deftype Frac

macro Int:a / Int:b {
    RETURN { num: a, den: b }
}

define int Frac:frac {
}


